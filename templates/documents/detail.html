{% extends "base.html" %}

{% block title %}{{ document.title }} - Writer Buddy{% endblock %}

{% block content %}
<div x-data="writerApp()" x-init="init()" class="h-screen flex flex-col bg-cream">
    <div class="border-b border-accent-light px-6 py-6 flex items-center justify-between flex-wrap gap-4">
        <div class="flex items-center gap-6">
            <a href="{% url 'document_list' %}" class="text-ink hover:text-accent transition-colors">
                ‚Üê Back
            </a>
            <input
                type="text"
                x-model="title"
                @input="debouncedSave()"
                class="text-2xl font-light bg-transparent border-none focus:outline-none focus:border-b border-accent-light px-2 py-1"
            >
        </div>

        <div class="flex items-center gap-6 flex-wrap text-lg">
            <button
                @click="mode = 'write'"
                :class="mode === 'write' ? 'border-b-2 border-ink' : 'text-gray-500 hover:text-ink'"
                class="transition-all pb-1"
            >
                Write
            </button>
            <button
                @click="mode = 'edit'"
                :class="mode === 'edit' ? 'border-b-2 border-ink' : 'text-gray-500 hover:text-ink'"
                class="transition-all pb-1"
            >
                Edit
            </button>
            <button
                @click="mode = 'review'"
                :class="mode === 'review' ? 'border-b-2 border-ink' : 'text-gray-500 hover:text-ink'"
                class="transition-all pb-1"
            >
                Review
            </button>

            <div class="flex items-center gap-2 text-sm">
                <div x-show="saving" class="flex items-center gap-2 text-gray-500">
                    <svg class="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Saving...
                </div>
                <div x-show="!saving && lastSaved" class="flex items-center gap-2 text-accent">
                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    Saved
                </div>
            </div>
        </div>
    </div>

    <div class="flex-1 flex overflow-hidden">
        <div x-show="mode === 'write'" class="flex-1 flex">
            <div class="flex-1 p-8 overflow-y-auto relative">
                 <textarea
                    x-ref="editor"
                    x-model="content"
                    @input="handleInput($event)"
                    @keyup="handleInput($event)"
                    @click="handleInput($event)"
                    class="w-full h-full resize-none focus:outline-none text-xl leading-loose font-serif relative text-ink bg-transparent caret-ink z-[2]"
                    placeholder="Start writing..."
                ></textarea>
                 <div x-show="settings.disappearing_text_enabled"
                     class="absolute top-8 left-8 pointer-events-none text-xl leading-loose font-serif whitespace-pre-wrap z-[1]"
                     x-html="fadedText">
                </div>
            </div>

            <div x-show="notesPaneOpen"
                 class="bg-accent-bg border-l border-accent-light p-6 overflow-y-auto transition-all"
                 :style="`width: ${notesPaneWidth}px`">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-light">Notes</h3>
                    <button @click="notesPaneOpen = false" class="text-gray-500 hover:text-ink text-2xl leading-none">&times;</button>
                </div>
                <textarea
                    x-model="notes"
                    @input="debouncedSave()"
                    class="w-full h-full p-4 border border-accent-light bg-cream resize-none focus:outline-none focus:border-gray-400 text-lg leading-relaxed font-serif"
                    placeholder="Add your notes here..."
                ></textarea>
            </div>

            <button x-show="!notesPaneOpen && mode === 'write'"
                    @click="notesPaneOpen = true"
                    class="absolute right-4 top-24 bg-ink hover:bg-accent text-cream px-4 py-2 transition-colors z-10">
                Notes
            </button>
        </div>

        <div x-show="mode === 'edit'" class="flex-1 flex">
             <div class="flex-1 p-8 overflow-y-auto relative">
                <div x-show="ruleMatches.length > 0"
                     class="absolute top-8 left-8 right-8 bottom-8 pointer-events-none font-mono text-lg leading-relaxed whitespace-pre-wrap z-[1]"
                     x-html="highlightedText">
                </div>
                <textarea
                    x-ref="editEditor"
                    x-model="content"
                    @input="handleEditInput($event)"
                    :class="ruleMatches.length > 0 ? 'text-transparent caret-ink' : ''"
                    class="w-full h-full resize-none focus:outline-none text-lg leading-relaxed font-mono relative bg-transparent z-[2]"
                ></textarea>
            </div>

            <div x-show="rulesPaneOpen"
                 class="w-full md:w-80 bg-accent-bg border-l border-accent-light p-6 overflow-y-auto absolute md:relative inset-0 md:inset-auto z-20 md:z-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-light">Editing Rules</h3>
                    <button @click="rulesPaneOpen = false" class="md:hidden text-gray-500 hover:text-ink text-2xl leading-none">&times;</button>
                </div>
                <div class="space-y-2 mb-4 max-h-48 overflow-y-auto">
                    <template x-for="rule in availableRules" :key="rule.id">
                        <label class="flex items-center gap-2">
                            <input type="checkbox"
                                   :checked="activeRuleIds.includes(rule.id)"
                                   @change="toggleRule(rule.id)"
                                   class="rounded">
                            <span class="text-sm" x-text="rule.name"></span>
                        </label>
                    </template>
                </div>

                <button @click="checkRules()" class="w-full bg-cream border border-ink hover:bg-accent-bg text-ink px-4 py-3 mb-4 transition-colors">
                    <span x-show="!checkingRules">Check Rules</span>
                    <span x-show="checkingRules" class="flex items-center justify-center gap-2">
                        <svg class="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Checking...
                    </span>
                </button>

                <div x-show="ruleMatches.length > 0" class="space-y-2">
                    <h4 class="font-semibold text-sm text-gray-700">Issues Found: <span x-text="ruleMatches.length"></span></h4>
                    <div class="text-xs space-y-2 max-h-96 overflow-y-auto">
                        <template x-for="(match, index) in ruleMatches" :key="index">
                            <div class="bg-yellow-50 p-2 rounded border border-yellow-200">
                                <div class="font-semibold" x-text="match.rule_name"></div>
                                <div class="text-gray-600 font-mono" x-text="match.text"></div>
                                <div class="text-gray-500 italic mt-1" x-text="match.suggestion"></div>
                            </div>
                        </template>
                    </div>
                </div>
            </div>

            <button x-show="!rulesPaneOpen && mode === 'edit'"
                    @click="rulesPaneOpen = true"
                    class="md:hidden fixed bottom-4 right-4 bg-ink hover:bg-accent text-cream px-4 py-3 z-10 border border-ink">
                Rules
            </button>
        </div>

        <div x-show="mode === 'review'" class="flex-1 flex flex-col">
            <div class="flex-1 p-8 overflow-y-auto max-w-none text-gray-700" x-html="renderedMarkdown"></div>

            <div class="bg-accent-bg border-t border-accent-light p-6 flex items-center justify-center gap-6">
                <a :href="`{% url 'document_export' document.pk %}?format=markdown`"
                   class="text-ink hover:text-accent transition-colors border-b border-current pb-1">
                    Export as Markdown
                </a>
                <button @click="generateShare()"
                        class="text-ink hover:text-accent transition-colors border-b border-current pb-1">
                    Share
                </button>
            </div>
        </div>
    </div>

</div>

<script>
function writerApp() {
    return {
        mode: '{{ mode }}',
        title: '{{ document.title|escapejs }}',
        content: `{{ document.content|escapejs }}`,
        notes: `{{ document.notes|escapejs }}`,
        settings: {{ settings_json|safe }},
        saving: false,
        lastSaved: null,
        saveTimeout: null,
        fadedText: '',
        availableRules: [],
        activeRuleIds: [],
        ruleMatches: [],
        highlightedText: '',
        notesPaneOpen: true,
        rulesPaneOpen: true,
        checkingRules: false,
        socket: null,
        shareUrl: '',

        init() {
            this.updateRenderedMarkdown();
            this.availableRules = {{ rules_json|safe }};
            this.connectWebSocket();
        },

        async generateShare() {
            try {
                const response = await fetch('{% url "document_generate_share" document.pk %}', {
                    method: 'POST',
                    headers: {'X-CSRFToken': '{{ csrf_token }}'}
                });
                const data = await response.json();
                this.shareUrl = data.url;
                prompt('Share this URL with collaborators:', data.url);
            } catch (error) {
                alert('Failed to generate share link');
            }
        },

        connectWebSocket() {
            const ws_scheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
            const ws_path = `${ws_scheme}://${window.location.host}/ws/document/{{ document.pk }}/`;
            this.socket = new WebSocket(ws_path);

            this.socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'content_update') {
                    this.content = data.content;
                }
            };

            this.socket.onopen = () => console.log('Connected to collaboration');
            this.socket.onerror = (error) => console.error('WebSocket error:', error);
        },

        sendUpdate() {
            if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                this.socket.send(JSON.stringify({
                    type: 'content_update',
                    content: this.content
                }));
            }
        },

        toggleRule(ruleId) {
            const index = this.activeRuleIds.indexOf(ruleId);
            if (index > -1) {
                this.activeRuleIds.splice(index, 1);
            } else {
                this.activeRuleIds.push(ruleId);
            }
        },

        async checkRules() {
            if (this.activeRuleIds.length === 0) {
                this.ruleMatches = [];
                this.highlightedText = '';
                return;
            }

            this.checkingRules = true;

            try {
                const response = await fetch('{% url "document_check_rules" document.pk %}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: JSON.stringify({
                        text: this.content,
                        rule_ids: this.activeRuleIds
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    this.ruleMatches = data.matches;
                    this.highlightMatches();
                }
            } catch (error) {
                console.error('Rule checking failed:', error);
            } finally {
                this.checkingRules = false;
            }
        },

        handleEditInput(event) {
            this.debouncedSave();
            if (this.activeRuleIds.length > 0) {
                clearTimeout(this.saveTimeout);
                this.saveTimeout = setTimeout(() => {
                    this.checkRules();
                    this.save();
                }, 2000);
            }
        },

        highlightMatches() {
            if (this.ruleMatches.length === 0) {
                this.highlightedText = this.escapeHtml(this.content);
                return;
            }

            let result = '';
            let lastIndex = 0;

            for (const match of this.ruleMatches) {
                result += this.escapeHtml(this.content.substring(lastIndex, match.start));
                result += `<span class="bg-yellow-200 border-b-2 border-yellow-500">${this.escapeHtml(match.text)}</span>`;
                lastIndex = match.end;
            }

            result += this.escapeHtml(this.content.substring(lastIndex));
            this.highlightedText = result;
        },

        handleInput(event) {
            if (this.settings.disappearing_text_enabled && this.mode === 'write') {
                this.applyDisappearingText(event.target);
            }
            this.debouncedSave();
            this.sendUpdate();
        },

        applyDisappearingText(textarea) {
            const visibleWords = this.settings.visible_words || 7;
            const cursorPos = textarea.selectionStart;

            const textBeforeCursor = this.content.substring(0, cursorPos);
            const textAfterCursor = this.content.substring(cursorPos);

            const wordsArray = textBeforeCursor.split(/(\s+)/);

            let result = '';
            let wordCount = 0;

            for (let i = wordsArray.length - 1; i >= 0; i--) {
                const segment = wordsArray[i];

                if (segment.trim()) {
                    wordCount++;
                }

                if (wordCount <= visibleWords) {
                    result = segment + result;
                } else {
                    const opacity = Math.max(0, 0.3 - (wordCount - visibleWords) * 0.1);
                    result = `<span style="opacity: ${opacity};">${this.escapeHtml(segment)}</span>` + result;
                }
            }

            result += this.escapeHtml(textAfterCursor);

            this.fadedText = result;
        },

        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        },

        debouncedSave() {
            clearTimeout(this.saveTimeout);
            this.saveTimeout = setTimeout(() => this.save(), 2000);
        },

        async save() {
            this.saving = true;
            try {
                const response = await fetch('{% url "document_autosave" document.pk %}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: JSON.stringify({
                        title: this.title,
                        content: this.content,
                        notes: this.notes
                    })
                });

                if (response.ok) {
                    this.lastSaved = new Date();
                    setTimeout(() => this.lastSaved = null, 3000);
                }
            } catch (error) {
                console.error('Save failed:', error);
            } finally {
                this.saving = false;
            }
        },

        async saveSettings() {
            try {
                await fetch('{% url "document_update_settings" document.pk %}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: JSON.stringify(this.settings)
                });
            } catch (error) {
                console.error('Settings save failed:', error);
            }
        },

        get renderedMarkdown() {
            if (typeof marked !== 'undefined') {
                return marked.parse(this.content);
            }
            return this.content.replace(/\n/g, '<br>');
        },

        updateRenderedMarkdown() {
            this.$watch('content', () => {
                this.renderedMarkdown;
            });
        },


    };
}
</script>
{% endblock %}
